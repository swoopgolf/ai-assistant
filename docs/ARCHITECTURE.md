# System Architecture & Best Practices

This document provides a comprehensive overview of the multi-agent framework's architecture and the best practices for designing agents within it. These guidelines are based on the principles of the Agent-to-Agent (A2A) protocol, as described in the [official A2A documentation](https://a2a-protocol.org/latest/topics/key-concepts/).

Adhering to these guidelines will ensure that agents are modular, scalable, secure, and interoperable.

## 1. Core Actors & Principles

The framework is designed around the three core actors defined in the A2A protocol:

-   **User:** The entity initiating a request.
-   **A2A Client (Client Agent):** The **Orchestrator Agent** in our framework. It acts on behalf of the user to delegate tasks.
-   **A2A Server (Remote Agent):** The **Specialist Agents** in our framework (created from the `agent_template`). They receive and process tasks.

Our architecture is built on these core A2A principles:
-   **Opaque Execution**: A Remote Agent's internal workings are a black box to the Client Agent.
-   **Hub-and-Spoke Model**: All communication is mediated by the Orchestrator.
-   **Asynchronous Operations**: All interactions are non-blocking to support long-running tasks.

## 2. Fundamental Communication Elements

A2A communication is built on several key elements:

-   **Task:** The central element of communication. When the Orchestrator delegates a request, it initiates a stateful `Task` in the Remote Agent (e.g., "generate a report"). This task has a lifecycle and is the unit of work.
-   **Message:** Represents a single turn of communication. It contains `Part` objects that carry the actual content.
-   **Part:** The fundamental unit of content within a `Message`. Can be text, structured JSON data, or a file.
-   **Artifact:** Represents a tangible output or result generated by the Remote Agent during the processing of a `Task` (e.g., the code generated by a coding agent).

## 3. A2A Communication Flow

1.  A request is sent to the **Orchestrator (Client Agent)**.
2.  The Orchestrator identifies the appropriate **Specialist Agent (Remote Agent)**.
3.  The Orchestrator delegates a **Task** to the Remote Agent by invoking one of its skills (e.g., via the `delegate_task_skill`).
4.  The Remote Agent executes the Task and returns the result, often as an **Artifact**.

## 4. Agent Registry & Discovery (Agent Cards)

The A2A protocol specifies that agents should be discoverable via an **Agent Card**. Our framework implements this concept using a centralized **Agent Registry**.

-   **Agent Registry (`config/system_config.yaml`):** This file is the single source of truth. It defines the "Agent Card" for every agent in the system, detailing its name, endpoint, description, and skills.
-   **Discovery:** The `AgentRegistry` class in `common_utils/agent_discovery.py` loads this configuration at startup, making all agents and their capabilities discoverable to the Orchestrator.

## 5. The Role of MCP: Agents vs. Tools

It is critical to understand that **agents are problem-solving collaborators, while tools are for executing well-defined actions.**

### Agent Interactions (A2A)
-   **Nature**: An open-ended, multi-turn dialogue centered around a `Task`. The agent is a *participant in problem solving*.
-   **Use Case**: Delegating complex requests like, "Generate a Python function that meets these requirements."

### Tool Interactions (MCP)
-   **Nature**: A discrete, time-boxed *unit of action*. An agent uses tools internally to help it complete a `Task`.
-   **Use Case**: An agent's internal interaction with a specific capability, like linting a piece of code.

## 6. Adding a New Agent

To add a new Remote Agent to the framework:

1.  Copy the `agent_template` directory.
2.  Implement the agent's specialized logic and tools.
3.  Add the new agent's "Agent Card" to the **Agent Registry** (`config/system_config.yaml`).

See `docs/adding_agents.md` for a more detailed guide. 